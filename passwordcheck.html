<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Password Strength Checker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/zxcvbn/4.4.2/zxcvbn.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        #password { font-size: 16px; padding: 5px; width: 600px; }
        #result { margin-top: 10px; }
        .compromised-yes { color: red; }
        .compromised-no { color: darkgreen; }
        .low-score { color: red; }
    </style>
</head>
<body>
    <input type="text" id="password" placeholder="Enter password" oninput="handleInput()">
    <div id="result"></div>

    <script>
        let checkTimer;
        let lastCheckedPassword = '';
        const commonWordsCache = new Set();
        const uncommonWordsCache = new Set();

        window.onload = function() {
            document.getElementById('password').focus();
        };

        function handleInput() {
            const password = document.getElementById('password').value;
            //document.getElementById('result').innerHTML = ''; // Analyzing...
            
            clearTimeout(checkTimer);
            checkTimer = setTimeout(() => checkPassword(password), 500);
        }

        async function checkPassword(password) {
            if (password.length === 0) {
                document.getElementById('result').innerHTML = '';
                return;
            }

            if (password !== document.getElementById('password').value) {
                document.getElementById('result').innerHTML = 'Analyzing...';
                return;
            }

            const result = zxcvbn(password);
            let score = Math.min(Math.round((result.guesses_log10 / 16) * 100), 100);

            const words = password.toLowerCase().match(/[^\s]+/g) || [];
            const commonWords = await dictionaryCheck(words);
            score = adjustScore(score, commonWords, words.length);

            const compromised = await checkCompromised(password);

            updateResult(password, score, commonWords, result, compromised);
        }

        function adjustScore(score, commonWords, totalWords) {
            const nonCommonWords = totalWords - commonWords.length;
            if (commonWords.length >= 3) {
                if (nonCommonWords === 0) {
                    score *= 0.5; // 50% reduction
                } else if (nonCommonWords === 1) {
                    score *= 0.7; // 30% reduction
                } else if (nonCommonWords === 2) {
                    score *= 0.9; // 10% reduction
                }
            }
            return Math.min(Math.round(score), 100);
        }

async function dictionaryCheck(words) {
    const commonWords = [];
    for (const word of words) {
        if (commonWordsCache.has(word)) {
            commonWords.push(word);
        } else if (!uncommonWordsCache.has(word)) {
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (response.ok) {
                    commonWords.push(word);
                    commonWordsCache.add(word);
                } else {
                    uncommonWordsCache.add(word);
                }
            } catch (error) {
                console.error('Dictionary API error:', error);
                // If there's an error, we'll assume it's not a common word
                uncommonWordsCache.add(word);
            }
        }
    }
    return commonWords;
}        

        function updateResult(password, score, commonWords, zxcvbnResult, compromised) {
            const hasLower = /[a-z]/.test(password);
            const hasUpper = /[A-Z]/.test(password);
            const hasNumber = /\d/.test(password);
            const hasSymbol = /[!@#$%^&*(),.?":{}|<>]/.test(password);
            const hasNoCommonWords = commonWords.length === 0;
            const length = password.length;
            const words = password.toLowerCase().match(/[^\s]+/g) || [];
            const passphraseNonCommonWords = (words.length >= 3 ? (words.length - commonWords.length) : 0);

            const compositionHtml = `
                <span style="color: ${hasLower ? 'green' : 'red'}">Lower case</span> -
                <span style="color: ${hasUpper ? 'green' : 'red'}">Upper case</span> -
                <span style="color: ${hasNumber ? 'green' : 'red'}">Numbers</span> -
                <span style="color: ${hasSymbol ? 'green' : 'red'}">Symbols</span>
                <!-- <span style="color: ${hasNoCommonWords ? 'green' : 'gray'}">No Common Words</span><br> -->
            `;

            const classicalCrackTime = zxcvbnResult.crack_times_display.offline_slow_hashing_1e4_per_second;
            const quantumCrackTime = estimateQuantumCrackTime(classicalCrackTime);
            const compromisedClass = compromised ? 'compromised-yes' : 'compromised-no';
            if (compromised) {
                score = 0;
            }

            document.getElementById('result').innerHTML = `
                ${compositionHtml}
                Length: ${length}<br>
                Pass-phrase non-common words: ${passphraseNonCommonWords}<br>
                Classical Crack time: ${classicalCrackTime}<br>
                Quantum Crack time: ${quantumCrackTime}<br>
                Score: <span class="${score < 90 ? 'low-score' : ''}">${score}/100</span><br>
                <span class="${compromisedClass}">Compromised: ${compromised ? 'Yes' : 'No'}</span>
            `;
        }

        function estimateQuantumCrackTime(classicalTime) {
            const timeUnits = {
                'centuries': 100 * 365 * 24 * 60 * 60,
                'years': 365 * 24 * 60 * 60,
                'months': 30 * 24 * 60 * 60,
                'weeks': 7 * 24 * 60 * 60,
                'days': 24 * 60 * 60,
                'hours': 60 * 60,
                'minutes': 60,
                'seconds': 1
            };

            let seconds = 0;
            for (const [unit, multiplier] of Object.entries(timeUnits)) {
                if (classicalTime.includes(unit)) {
                    seconds = parseFloat(classicalTime) * multiplier;
                    break;
                }
            }

            const quantumSeconds = Math.sqrt(seconds);
            if (isNaN(quantumSeconds) || !isFinite(quantumSeconds)) return "Extremely long";
            if (quantumSeconds < 60) return `${Math.round(quantumSeconds)} seconds`;
            if (quantumSeconds < 3600) return `${Math.round(quantumSeconds / 60)} minutes`;
            if (quantumSeconds < 86400) return `${Math.round(quantumSeconds / 3600)} hours`;
            if (quantumSeconds < 2592000) return `${Math.round(quantumSeconds / 86400)} days`;
            if (quantumSeconds < 31536000) return `${Math.round(quantumSeconds / 2592000)} months`;
            return `${Math.round(quantumSeconds / 31536000)} years`;
        }

        async function checkCompromised(password) {
            if (password.length === 0) return false;
            const sha1 = await sha1Hash(password);
            const prefix = sha1.substring(0, 5);
            const suffix = sha1.substring(5);
            const response = await fetch(`https://api.pwnedpasswords.com/range/${prefix}`);
            const text = await response.text();
            return text.includes(suffix.toUpperCase());
        }

        async function sha1Hash(str) {
            const buffer = new TextEncoder().encode(str);
            const hash = await crypto.subtle.digest('SHA-1', buffer);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }
        
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('password').focus();
});


    </script>
</body>
</html>
