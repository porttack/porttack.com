<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Password Strength Checker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/zxcvbn/4.4.2/zxcvbn.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; text-align: center; }
        #password { font-size: 16px; padding: 5px; width: 600px; }
        #result { margin-top: 10px; }
        .compromised-yes { color: red; }
        .compromised-no { color: darkgreen; }
        .low-score { color: red; }
    </style>
</head>
<body>
    <input type="text" id="password" placeholder="Enter password" oninput="checkPassword()">
    <div id="result"></div>

    <script>
        let lastCheckedPassword = '';
        let debounceTimer;
        let dictionaryCheckTimer;

        // Focus on the password input when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('password').focus();
        });

        function checkPassword() {
            const password = document.getElementById('password').value;
            if (password.length === 0) {
                document.getElementById('result').innerHTML = '';
                return;
            }

            const result = zxcvbn(password);
            let score = Math.round((result.guesses_log10 / 16) * 100);

            // Clear previous timers
            clearTimeout(debounceTimer);
            clearTimeout(dictionaryCheckTimer);

            // Set new timer for dictionary check
            dictionaryCheckTimer = setTimeout(() => {
                const words = password.toLowerCase().match(/[a-z]+/g) || [];
                dictionaryCheck(words).then(commonWords => {
                    score = adjustScore(score, commonWords, words.length);
                    updateResult(password, score, commonWords, result);
                });
            }, 4000);

            // Update result immediately with initial score
            updateResult(password, score, [], result);

            // Debounce for compromised check
            debounceTimer = setTimeout(async () => {
                if (password !== lastCheckedPassword) {
                    lastCheckedPassword = password;
                    const compromised = await checkCompromised(password);
                    updateCompromisedStatus(compromised);
                }
            }, 300);
        }

        function adjustScore(score, commonWords, totalWords) {
            const nonCommonWords = totalWords - commonWords.length;
            if (nonCommonWords === 0) {
                return score * 0.5; // 50% reduction
            } else if (nonCommonWords === 1) {
                return score * 0.7; // 30% reduction
            } else if (nonCommonWords === 2) {
                return score * 0.9; // 10% reduction
            }
            return score; // No reduction
        }

        async function dictionaryCheck(words) {
            const commonWords = [];
            for (const word of words) {
                try {
                    const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                    if (response.ok) {
                        commonWords.push(word);
                    }
                } catch (error) {
                    console.error('Dictionary API error:', error);
                }
            }
            return commonWords;
        }

        function updateResult(password, score, commonWords, zxcvbnResult) {
            const hasLower = /[a-z]/.test(password);
            const hasUpper = /[A-Z]/.test(password);
            const hasNumber = /\d/.test(password);
            const hasSymbol = /[!@#$%^&*(),.?":{}|<>]/.test(password);
            const hasNoCommonWords = commonWords.length === 0;

            const compositionHtml = `
                <span style="color: ${hasLower ? 'green' : 'gray'}">Lower case</span>
                <span style="color: ${hasUpper ? 'green' : 'gray'}">Upper case</span>
                <span style="color: ${hasNumber ? 'green' : 'gray'}">Numbers</span>
                <span style="color: ${hasSymbol ? 'green' : 'gray'}">Symbols</span>
                <span style="color: ${hasNoCommonWords ? 'green' : 'gray'}">No Common Words</span><br>
            `;

            const classicalCrackTime = zxcvbnResult.crack_times_display.offline_slow_hashing_1e4_per_second;
            const quantumCrackTime = estimateQuantumCrackTime(classicalCrackTime);

            document.getElementById('result').innerHTML = `
                ${compositionHtml}
                Classical Crack time: ${classicalCrackTime}<br>
                Quantum Crack time: ${quantumCrackTime}<br>
                Score: <span class="${score < 90 ? 'low-score' : ''}">${Math.round(score)}/100</span>
            `;
        }

        function updateCompromisedStatus(compromised) {
            const compromisedClass = compromised ? 'compromised-yes' : 'compromised-no';
            document.getElementById('result').innerHTML += `
                <br><span class="${compromisedClass}">Compromised: ${compromised ? 'Yes' : 'No'}</span>
            `;
        }

        function estimateQuantumCrackTime(classicalTime) {
            const timeUnits = {
                'centuries': 100 * 365 * 24 * 60 * 60,
                'years': 365 * 24 * 60 * 60,
                'months': 30 * 24 * 60 * 60,
                'weeks': 7 * 24 * 60 * 60,
                'days': 24 * 60 * 60,
                'hours': 60 * 60,
                'minutes': 60,
                'seconds': 1
            };

            let seconds = 0;
            for (const [unit, multiplier] of Object.entries(timeUnits)) {
                if (classicalTime.includes(unit)) {
                    seconds = parseFloat(classicalTime) * multiplier;
                    break;
                }
            }

            const quantumSeconds = Math.sqrt(seconds);
            if (isNaN(quantumSeconds) || !isFinite(quantumSeconds)) return "Extremely long";
            if (quantumSeconds < 60) return `${Math.round(quantumSeconds)} seconds`;
            if (quantumSeconds < 3600) return `${Math.round(quantumSeconds / 60)} minutes`;
            if (quantumSeconds < 86400) return `${Math.round(quantumSeconds / 3600)} hours`;
            if (quantumSeconds < 2592000) return `${Math.round(quantumSeconds / 86400)} days`;
            if (quantumSeconds < 31536000) return `${Math.round(quantumSeconds / 2592000)} months`;
            return `${Math.round(quantumSeconds / 31536000)} years`;
        }

        async function checkCompromised(password) {
            if (password.length === 0) return false;
            const sha1 = await sha1Hash(password);
            const prefix = sha1.substring(0, 5);
            const suffix = sha1.substring(5);
            const response = await fetch(`https://api.pwnedpasswords.com/range/${prefix}`);
            const text = await response.text();
            return text.includes(suffix.toUpperCase());
        }

        async function sha1Hash(str) {
            const buffer = new TextEncoder().encode(str);
            const hash = await crypto.subtle.digest('SHA-1', buffer);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        // Initial check on page load
        checkPassword();
    </script>
</body>
</html>
